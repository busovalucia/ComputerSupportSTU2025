---
title: "Computer Support Practical Tasks"
date: "10/13/2025"
format:
  html:
    embed-resources: true
editor: source
---

## Introduction

For performing practical tasks **R** and **R Studio** have to be installed.

Links for downloading programs: 

1. R: <https://cran.r-project.org/>

2. R Studio: <https://posit.co/download/rstudio-desktop/>

3. Quarto: <https://quarto.org/docs/get-started/> 

The results of laboratory work must be placed in your repository on Github in the files `TaskX.qmd` (or `LabX.Rmd` if you prefer to use R markdown) and generated from it `TaskX.html`, where X is the number of the laboratory in the form: **question**, **code**, **result** (if necessary). So, the file structure could looks like:

```
--ComputerSupportSTU
  |--Task1.qmd
  |--Task1.html
  |--Task2.qmd
  |--Task2.html
```
Use a template for `qmd` document (file `template.qmd`) to generate correct html file

Example of output:

1.  Print rownames of dataset `mtcars`.

```{r}
row.names(mtcars)
```

## Task 0

1.  Create Github account
2.  Create new repository "ComputerSupportSTU"
3.  In readme.md file add title a short repository description

## Task 1: Exploring Data Types in R

You will create a small “universe” of data in R, using all major data types.

Your goal is to combine **creativity**, **logical thinking**, and **coding precision**.

You may choose **any theme** — a **fictional character**, **city**, **planet**, **company**, **ecosystem**, or even **your pet**. Everything you create in R should belong to this “mini universe.”

### 1.1. Atomic Types

Create the following variables related to your chosen object:

- **4 numeric** values (e.g., population, temperature, size, rating)  
- **3 integer** values (e.g., number of moons, buildings, inhabitants)  
- **2 logical** values (e.g., `has_water`, `is_inhabited`)  
- **3 character** values (e.g., `name`, `region`, `category`)

**Tip:** Think of these variables as *attributes* of your object.  
Use `print()` or `cat()` to describe them in one sentence.

### 1.2. Vectors

Create three different vectors:

1. **Numeric vector** combining all your numeric and integer variables.  
   *(Use `c()`.)*

2. **Sequence vector** from any number between 10–50 to 100, Choose step between 2 and 10.  
   *(Use `seq()` or `:`.)*

3. **Logical vector** of length 10 with random `TRUE`/`FALSE` values using `sample()`.

### 1.3. Matrix

Create a **3×3 matrix** with random numbers between **-50 and 50**  
(using `sample()` or `runif()`), and name its **rows and columns** according to your theme.

Then calculate row and column averages using `rowMeans()` and `colMeans()`.

### 1.4. List

Create a **list** that combines all your previous objects:  
atomic variables, vectors, and matrix.
Add one extra element — a short **description** of your universe as a string.

### 1.5. Factor

Create a **factor variable** representing categories within your universe, e.g.:

- `"low"`, `"medium"`, `"high"`  
- `"infant"`, `"child"`, `"adult"`  
- `"poor"`, `"average"`, `"rich"`

Make sure you have **at least 5 observations** total.  
Then use `table()` to show how many objects fall into each category.

### 1.6. Data Frame

Create a **data frame** related to your object that includes:

1. **5–8 observations** (rows)  
2. **At least 3 columns** of different data types  
   (e.g., name, numeric value, logical flag, category)

Then:

- Rename the columns using `names()` or `colnames()`.  
- Display its structure with `str()` and its summary with `summary()`.  
- Add a new column derived from the others (for example, a ratio or condition).

## Task 2: Subsetting & Missing Data

### 2.1. Querying Vectors

Let's start with the vectors you created in **Task 1**.

2.1.1. From your **Sequence vector** (the one with all your numbers):

- Select and print the 3rd element.
- Select and print elements 2 through 5.
- Select and print all values that are greater than 20 (or another number that makes sense for your data).

2.1.2. From your **Logical vector**:

- Select and print only the TRUE values. (Hint: `your_vector[your_vector]`).
- Use `which()` to get the indices (positions) of all the `TRUE` values.

### 2.2. Querying Your "Universe" List

Use your main list from **Task 1**.

- Access and print the **description** string using the `$` operator
- Access and print your **3x3 matrix** using double brackets `[[ ]]`.
- Access and print the **second element** from your **vector element** within the list. (This will be a "list-within-a-list" access).

### 2.3. Investigating Your Data Frame

Use the **data frame** you created in **Task 1**.

- Print the **first 3 rows**. (Use `head()`.)
- Print the value from the **4th row, 1st column**.
- Print only the column that contains your logical values (e.g., `is_habitable`) as a vector.

**Logical Subsetting**: Create a new data frame `df_subset` that contains only the rows that meet a specific logical condition.

- Example: `df_subset <- your_df[your_df$population > 1000, ]`

`%in%` **Subsetting**: Create a new data frame `df_subset_2` that selects rows belonging to **two specific categories** from your factor or character column.

- Example: `df_subset_2 <- your_df[your_df$region %in% c("North", "South"), ]`

### 2.4. Handling "Corrupted" Data (`NA`)

Create a copy of your original data frame (e.g., `df_corrupted <- your_df`).

**Introduce 3 `NA`s** into your df_corrupted at specific locations.

- Example: `df_corrupted[2, 3] <- NA`

**Find `NAs`**:

- Use `sum(is.na(df_corrupted)`) to find the **total number** of missing values.
- Use `colSums(is.na(df_corrupted))` to see how many `NA`s are in **each column**.

**Calculate with `NA`s**:

- Calculate the `mean()` of the numeric column where you added an `NA`.

**Filter `NA`s**:

- Use `na.omit(df_corrupted)` to create a new, "clean" data frame that contains only the complete rows.

### 2.5. Bonus Challenge: `which()`

Use `which.max()` or `which.min()` to find the **row number** (index) of the observation with the highest or lowest value in one of your numeric columns.

Use that index to print the row with that observation.

- Example: `highest_pop_index <- which.max(your_df$population)`
- Example: `your_df[highest_pop_index, ]`

## Task 3: Expanding Your Universe

Your "mini-universe" in Tasks 1 & 2 was a simulation. Now, it's time to connect it to the real world.

Your mission is to find a real dataset that expands on your theme, import it into R, and explore it using the dplyr package.

### 3.1. The Quest: Find Your Data

Find one simple, real-world dataset that fits your theme.

- **Where to look**: Kaggle, TidyTuesday, data.gov, or other public data portals.

- **Format**: Any format you are able to read. For simplicity it is proposed to use **textual (csv, txt)** or **Excel** format.

- **Requirements**:

    - At least 50 rows.

    - At least 4 columns.

    - A mix of numeric and character/factor data.

- **Action**:

    1. Download the data file and place it in your R project directory.

    2. In your task file add a line with the link to the data source (e.g., Data from: https://...).
    
### 3.2. The Import: Load Your Data

1. **Install** `tidyverse`: If you haven't, run `install.packages("tidyverse")` in your console (just once).

2. **Load libraries**: At the top of your script, add `library(dplyr)` and `library(readr)` (`library(readxl)` in case of Excel file format).

3. **Read the data**: Use `read_csv()` (or `read_excel()`) to load your dataset into a new data frame.

```r
# Load the Tidyverse libraries
library(dplyr)
library(readr)

# Load your data (replace with your file's name)
my_real_data <- read_csv("your_dataset_name.csv")
```

4. **First Inspection**: Immediately after loading, inspect your data to make sure it loaded correctly.

```r
# See the structure and column types
glimpse(my_real_data)

# See the first 6 rows
head(my_real_data)

# Get a statistical summary
summary(my_real_data)
```

### 3.3. The Interrogation: Explore with `dplyr`

This is the core of the task. Your goal is to **ask and answer 5 interesting questions** about your new dataset.

You must write the question in plain English (as a comment), followed by the `dplyr` code that answers it.

You **must** use each of the following `dplyr` "verbs" at least once:

- `select()` - To pick specific columns.

- `filter()` - To subset rows based on a condition.

- `arrange()` - To sort your results (e.g., with desc()).

- `mutate()` - To create a new column.

`group_by()` and `summarise()` - To get summary statistics (like `mean()`, `n()`, `max()`, etc.).

**Your 5 Questions (example):**

Here are examples. **Do not copy these**. Create your own questions based on your data.

**Question 1**: Which 5 cities have the highest population?

```r
my_real_data %>%
  select(city, population) |> 
  arrange(desc(population)) |> 
  head(5)
```

**Question 2**: What is the average temperature for each planet_type?

```r
my_real_data |> 
  group_by(planet_type) |> 
  summarise(avg_temp = mean(temperature, na.rm = TRUE))
```

**Question 3**: How many pets are there of each animal_type?

```r
my_real_data |> 
  group_by(animal_type) |> 
  summarise(count = n())
```

**Question 4**: What is the population density for each city?

```r
my_real_data |> 
  filter(!is.na(population) & !is.na(area_sq_km)) |> 
  mutate(density = population / area_sq_km) |> 
  select(city, density)
```

**Question 5**: Find all successful missions launched after 2010.

```r
my_real_data |> 
  filter(launch_year > 2010, status == "Successful") |> 
  select(mission_name, launch_year, status)
```

