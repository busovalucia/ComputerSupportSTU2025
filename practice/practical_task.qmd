---
title: "Computer Support Practical Tasks"
date: "10/13/2025"
format:
  html:
    embed-resources: true
editor: source
---

## Introduction

For performing practical tasks **R** and **R Studio** have to be installed.

Links for downloading programs: 

1. R: <https://cran.r-project.org/>

2. R Studio: <https://posit.co/download/rstudio-desktop/>

3. Quarto: <https://quarto.org/docs/get-started/> 

The results of laboratory work must be placed in your repository on Github in the files `TaskX.qmd` (or `LabX.Rmd` if you prefer to use R markdown) and generated from it `TaskX.html`, where X is the number of the laboratory in the form: **question**, **code**, **result** (if necessary). So, the file structure could looks like:

```
--ComputerSupportSTU
  |--Task1.qmd
  |--Task1.html
  |--Task2.qmd
  |--Task2.html
```
Use a template for `qmd` document (file `template.qmd`) to generate correct html file

Example of output:

1.  Print rownames of dataset `mtcars`.

```{r}
row.names(mtcars)
```

## Task 0

1.  Create Github account
2.  Create new repository "ComputerSupportSTU"
3.  In readme.md file add title a short repository description

## Task 1: Exploring Data Types in R

You will create a small “universe” of data in R, using all major data types.

Your goal is to combine **creativity**, **logical thinking**, and **coding precision**.

You may choose **any theme** — a **fictional character**, **city**, **planet**, **company**, **ecosystem**, or even **your pet**. Everything you create in R should belong to this “mini universe.”

### 1.1. Atomic Types

Create the following variables related to your chosen object:

- **4 numeric** values (e.g., population, temperature, size, rating)  
- **3 integer** values (e.g., number of moons, buildings, inhabitants)  
- **2 logical** values (e.g., `has_water`, `is_inhabited`)  
- **3 character** values (e.g., `name`, `region`, `category`)

**Tip:** Think of these variables as *attributes* of your object.  
Use `print()` or `cat()` to describe them in one sentence.

### 1.2. Vectors

Create three different vectors:

1. **Numeric vector** combining all your numeric and integer variables.  
   *(Use `c()`.)*

2. **Sequence vector** from any number between 10–50 to 100, Choose step between 2 and 10.  
   *(Use `seq()` or `:`.)*

3. **Logical vector** of length 10 with random `TRUE`/`FALSE` values using `sample()`.

### 1.3. Matrix

Create a **3×3 matrix** with random numbers between **-50 and 50**  
(using `sample()` or `runif()`), and name its **rows and columns** according to your theme.

Then calculate row and column averages using `rowMeans()` and `colMeans()`.

### 1.4. List

Create a **list** that combines all your previous objects:  
atomic variables, vectors, and matrix.
Add one extra element — a short **description** of your universe as a string.

### 1.5. Factor

Create a **factor variable** representing categories within your universe, e.g.:

- `"low"`, `"medium"`, `"high"`  
- `"infant"`, `"child"`, `"adult"`  
- `"poor"`, `"average"`, `"rich"`

Make sure you have **at least 5 observations** total.  
Then use `table()` to show how many objects fall into each category.

### 1.6. Data Frame

Create a **data frame** related to your object that includes:

1. **5–8 observations** (rows)  
2. **At least 3 columns** of different data types  
   (e.g., name, numeric value, logical flag, category)

Then:

- Rename the columns using `names()` or `colnames()`.  
- Display its structure with `str()` and its summary with `summary()`.  
- Add a new column derived from the others (for example, a ratio or condition).

## Task 2: Subsetting & Missing Data

### 2.1. Querying Vectors

Let's start with the vectors you created in **Task 1**.

2.1.1. From your **Sequence vector** (the one with all your numbers):

- Select and print the 3rd element.
- Select and print elements 2 through 5.
- Select and print all values that are greater than 20 (or another number that makes sense for your data).

2.1.2. From your **Logical vector:**

- Select and print only the TRUE values. (Hint: `your_vector[your_vector]`).
- Use `which()` to get the indices (positions) of all the `TRUE` values.

### 2.2. Querying Your "Universe" List

Use your main list from **Task 1**.

- Access and print the **description** string using the `$` operator
- Access and print your **3x3 matrix** using double brackets `[[ ]]`.
- Access and print the **second element** from your **vector element** within the list. (This will be a "list-within-a-list" access).

### 2.3. Investigating Your Data Frame

Use the **data frame** you created in **Task 1**.

- Print the **first 3 rows**. (Use `head()`.)
- Print the value from the **4th row, 1st column**.
- Print only the column that contains your logical values (e.g., `is_habitable`) as a vector.

**Logical Subsetting:** Create a new data frame `df_subset` that contains only the rows that meet a specific logical condition.

- Example: `df_subset <- your_df[your_df$population > 1000, ]`

`%in%` **Subsetting:** Create a new data frame `df_subset_2` that selects rows belonging to **two specific categories** from your factor or character column.

- Example: `df_subset_2 <- your_df[your_df$region %in% c("North", "South"), ]`

### 2.4. Handling "Corrupted" Data (`NA`)

Create a copy of your original data frame (e.g., `df_corrupted <- your_df`).

**Introduce 3 `NA`s** into your df_corrupted at specific locations.

- Example: `df_corrupted[2, 3] <- NA`

**Find `NAs`:**

- Use `sum(is.na(df_corrupted)`) to find the **total number** of missing values.
- Use `colSums(is.na(df_corrupted))` to see how many `NA`s are in **each column**.

**Calculate with `NA`s:**

- Calculate the `mean()` of the numeric column where you added an `NA`.

**Filter `NA`s:**

- Use `na.omit(df_corrupted)` to create a new, "clean" data frame that contains only the complete rows.

### 2.5. Bonus Challenge: `which()`

Use `which.max()` or `which.min()` to find the **row number** (index) of the observation with the highest or lowest value in one of your numeric columns.

Use that index to print the row with that observation.

- Example: `highest_pop_index <- which.max(your_df$population)`
- Example: `your_df[highest_pop_index, ]`

## Task 3: Expanding Your Universe

Your "mini-universe" in Tasks 1 & 2 was a simulation. Now, it's time to connect it to the real world.

Your mission is to find a real dataset that expands on your theme, import it into R, and explore it using the dplyr package.

### 3.1. The Quest: Find Your Data

Find one simple, real-world dataset that fits your theme.

- **Where to look:** Kaggle, TidyTuesday, data.gov, or other public data portals.

- **Format:** Any format you are able to read. For simplicity it is proposed to use **textual (csv, txt)** or **Excel** format.

- **Requirements:**

    - At least 50 rows.

    - At least 4 columns.

    - A mix of numeric and character/factor data.

- **Action:**

    1. Download the data file and place it in your R project directory.

    2. In your task file add a line with the link to the data source (e.g., Data from: https://...).
    
### 3.2. The Import: Load Your Data

1. **Install** `tidyverse`: If you haven't, run `install.packages("tidyverse")` in your console (just once).

2. **Load libraries:** At the top of your script, add `library(dplyr)` and `library(readr)` (`library(readxl)` in case of Excel file format).

3. **Read the data:** Use `read_csv()` (or `read_excel()`) to load your dataset into a new data frame.

```r
# Load the Tidyverse libraries
library(dplyr)
library(readr)

# Load your data (replace with your file's name)
my_real_data <- read_csv("your_dataset_name.csv")
```

4. **First Inspection:** Immediately after loading, inspect your data to make sure it loaded correctly.

```r
# See the structure and column types
glimpse(my_real_data)

# See the first 6 rows
head(my_real_data)

# Get a statistical summary
summary(my_real_data)
```

### 3.3. The Interrogation: Explore with `dplyr`

This is the core of the task. Your goal is to **ask and answer 5 interesting questions** about your new dataset.

You must write the question in plain English (as a comment), followed by the `dplyr` code that answers it.

You **must** use each of the following `dplyr` "verbs" at least once:

- `select()` - To pick specific columns.

- `filter()` - To subset rows based on a condition.

- `arrange()` - To sort your results (e.g., with desc()).

- `mutate()` - To create a new column.

`group_by()` and `summarise()` - To get summary statistics (like `mean()`, `n()`, `max()`, etc.).

**Your 5 Questions (example):**

Here are examples. **Do not copy these**. Create your own questions based on your data.

**Question 1:** Which 5 cities have the highest population?

```r
my_real_data %>%
  select(city, population) |> 
  arrange(desc(population)) |> 
  head(5)
```

**Question 2:** What is the average temperature for each planet_type?

```r
my_real_data |> 
  group_by(planet_type) |> 
  summarise(avg_temp = mean(temperature, na.rm = TRUE))
```

**Question 3:** How many pets are there of each animal_type?

```r
my_real_data |> 
  group_by(animal_type) |> 
  summarise(count = n())
```

**Question 4:** What is the population density for each city?

```r
my_real_data |> 
  filter(!is.na(population) & !is.na(area_sq_km)) |> 
  mutate(density = population / area_sq_km) |> 
  select(city, density)
```

**Question 5:** Find all successful missions launched after 2010.

```r
my_real_data |> 
  filter(launch_year > 2010, status == "Successful") |> 
  select(mission_name, launch_year, status)
```

## Task 4. Building a "Toolkit" for Your Universe (Functions)

In Task 3, you performed a "one-off" analysis of your new dataset. In the real world, you'll want to run that analysis again and again.

The best way to do this is by capturing your code inside **functions**. A function is a reusable "tool" that you build to perform a specific job.

Your mission is to build a "toolkit" of functions that can analyse the dataset you found in Task 3.

**Important:** You must use the **same dataset** and theme you used in Task 3.

### 4.1. The "Greeting" Function (A Simple Start)

Let's start with the basics. Write a simple function that prints a welcome message for your "universe".

1. **Write the function:** It should take at least one argument (e.g., `your_name` or `universe_name`).

2. **Inside the function:** Use `print()` or `cat()` to display a message.

3. **Call the function:** After you define the function, you must call it to see the result.

```r
# Example function (create your own!)

welcome_to_my_universe <- function(your_name) {
  cat("--------------------------------\n")
  cat("Analysis Toolkit for [My Universe Name]\n")
  cat("Report prepared by:", your_name, "\n")
  cat("--------------------------------\n")
}

# Now, call the function:
welcome_to_my_universe("Your Name Here")
```

### 4.2. The "Loading" Function (A Good Practice)

In Task 3, you wrote code to load and inspect your data. Let's turn that into a function. This is a very common and useful practice.

1. **Write the function:** Name it `load_and_inspect`. It should take one argument: `file_path`.

2. **Inside the function:**

  - Load the `readr` and `dplyr` libraries.

  - Use `read_csv(file_path)` to load the data.

  - Print a message (e.g., "Data loaded successfully.").

  - Print the `glimpse()` of the data.

  - Print the `head()` of the data.

  - **Return** the data frame (use the `return()` command).

3. **Call the function:**

```r
# Load the libraries
library(readr)
library(dplyr)

load_and_inspect <- function(file_path) {
  data <- read_csv(file_path)
  cat("--- Data Loaded:", file_path, "---\n")
  print(glimpse(data))
  cat("\n--- First 6 Rows: ---\n")
  print(head(data))
  return(data)
}

# Call the function, saving its output to a variable
# (Replace with your file's name)
my_data <- load_and_inspect("your_dataset_name.csv")
```

### 4.3. The "Query" Function (The Core of the Task)

This is the most important step. You will turn one of your `dplyr` queries from **Task 3** into a reusable function.

Look back at your Task 3 code. You probably wrote something like this:

  - `my_data |> filter(population > 1000000)`

  - `my_data |> filter(planet_type == "Gas Giant")`

That 1000000 or "Gas Giant" is a "magic number" or "magic string". A function lets you turn it into a parameter.

1. **Choose a query:** Pick one of your `filter()` or `summarise()` queries from Task 3.

2. **Write the function:**
  
  - Give it a descriptive name (e.g., `find_pollution_by_disctrict`, `filter_cities_by_population`).

  - It must take at least two arguments: **data** (for the data frame) and a **parameter** for the value you want to change (e.g., `pop_threshold` or `type_name`).

  - The function should perform the `dplyr` query and `return` the result.

**Example:** Let's say in Task 3 you found population density for each city.

```r
my_real_data |> 
  filter(!is.na(population) & !is.na(area_sq_km)) |> 
  mutate(density = population / area_sq_km) |> 
  select(city, density)
```

**Now, let's turn it into a function for Task 4:**

```r
find_population_density <- function(data, city_name) {
  result <- data |>
    filter(city == city_name) |> 
    filter(!is.na(population) & !is.na(area_sq_km)) |> 
    mutate(density = population / area_sq_km) |> 
    select(city, density)
  
  return(result)
}

# Call your new function (using the 'my_data' from step 4.2)
population_density_city_A_name <- find_population_density(my_data, "city_A_name")

# Print the results to see it work
print(population_density_city_A_name)
```

**Your Task**: Write and call your **own** query function based on **your data**.

### 4.4. The "Reporting" Function

Let's combine everything. Write a single function that calculates several key statistics for a specific **group** or **category** in your data.

1. **Write the function:** Name it `generate_report`. It should take `data` and a `category_name` as arguments (e.g., a specific city, planet type, or region).

2. **Inside the function**:

    - `filter()` your data for only the `category_name` provided.

    - Calculate 3-4 interesting summary statistics (e.g., `mean()`, `max()`, `min()`, `n()`).

    - Use `cat()` to print a nicely formatted "report" to the console.

**Example:**

```r
generate_report <- function(data, city_name) {
  
  # 1. Filter for just that city
  city_data <- data |> 
    filter(city == city_name)
    
  # 2. Calculate stats
  # (Note: na.rm = TRUE is good practice!)
  avg_temp <- mean(city_data$temperature, na.rm = TRUE)
  max_pop <- max(city_data$population, na.rm = TRUE)
  record_count <- nrow(city_data)
  
  # 3. Print the report
  cat("--- Report for:", city_name, "---\n")
  cat("Number of Records Found:", record_count, "\n")
  cat("Average Temperature:", round(avg_temp, 2), "\n")
  cat("Maximum Population:", max_pop, "\n")
  cat("----------------------------------\n\n")
}

# Call your function for two different categories:
generate_report(my_data, "City_A_Name")
generate_report(my_data, "City_B_Name")
```

**Your Task:** Write and call **your own** reporting function based on your data.
